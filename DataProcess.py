# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ds43Lrx949y5RiC4LXWt-f_q9FGjdY9D

Importing Required Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from os.path import join
from google.colab import drive
import random as rdn
from scipy import stats
from datetime import datetime
from scipy.spatial.distance import cdist
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import time
import logging

"""Connect Project To Google Drive"""

# Connecting Google Drive
drive.mount('/content/drive')
!ls
!ls drive

df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/tracks_features.csv")

"""General Info About The DataSet"""

# Show First 60 rows to get general idea for Dataset and think about general operations which will be apply to dataset.
df.head(60)

df['key'].head(40)

df['loudness'].head(40)

df['mode'].head(20)

"""Description Of The Dataset(EDA)"""

print("Number of rows:", df.shape[0])
print("Number of Columns:", df.shape[1])

"""Drop dublicated rows."""

df = df.drop_duplicates()
df

print("Number of rows:", df.shape[0])
print("Number of Columns:", df.shape[1])

"""We dont have any dublicated rows"""

print("Getting information about each columns non-null counts and their data types:\n")
print(df.info(), "\n\n")
print("Getting how many rows are null for each feature:\n\n", df.isna().sum())

"""As seen above We do not have any null values but we can remove the column named explicit because it is useless for our purpose."""

df.info()

"""Converting time_signature column which is in float data type into integer."""

df['time_signature'] = df['time_signature'].astype(int)
df.info()

"""Converting year column which is int data type into string."""

#df['year'] = df['year'].astype(str)
#df.info()

"""If There are null values in our data frame like Null,N/a,NaN They will fill with blank"""

df.fillna('')

df['release_date'] < ('1800-01-01')

df[df['release_date'].isnull() | (df['release_date'] < '1900-01-01') | (df['release_date'] > '2023-11-15')].head()

invalid_dates = df[df['release_date'].isnull() | (df['release_date'] < '1900-01-01') | (df['release_date'] > '2023-11-15')].head()

df = df.applymap(lambda x: '' if x in invalid_dates else x)

df

df['release_date'] = pd.to_datetime(df['release_date'], errors='coerce')

df

df.info()

df.head(10)

df['artist_ids'] = df['artist_ids'].apply(lambda x: str(x).replace("[", "").replace("]", ""))
df['artist_ids'] = df['artist_ids'].apply(lambda x: str(x).replace("'", ""))
df['artists'] = df['artists'].apply(lambda x: str(x).replace("[", "").replace("]", ""))
df['artists'] = df['artists'].apply(lambda x: str(x).replace("'", ""))
df

def GetUrlForArtistSongs(artist_ids):
    URL = "https://open.spotify.com/intl-tr/" + "artist" + "/" + artist_ids
    return URL

pd.set_option('display.max_colwidth', None)
df['ArtistSongsURL'] = df.apply(lambda row: GetUrlForArtistSongs(row['artist_ids']), axis=1)
df

df['ArtistSongsURL'].head(10)

def GetUrlForAlbumSongs(album_id):
    URL = "https://open.spotify.com/intl-tr/" + "album" + "/" + album_id
    return URL

pd.set_option('display.max_colwidth', None)
df['AlbumSongsURL'] = df.apply(lambda row: GetUrlForAlbumSongs(row['album_id']), axis=1)

df

def GetUrlForTracks(id):
    URL = "https://open.spotify.com/intl-tr/" + "track" + "/" + id
    return URL

pd.set_option('display.max_colwidth', None)
df['TracksUrl'] = df.apply(lambda row: GetUrlForTracks(row['id']), axis=1)

df

print("ArtistSongsURL")
df['ArtistSongsURL'].head(5)

print("AlbumSongsURL")
df['AlbumSongsURL'].head(5)

print("TracksUrl")
df['TracksUrl'].head(5)

df['release_date'] = pd.to_datetime(df['release_date'], errors='coerce').apply(lambda x: x.strftime('%d/%m/%Y') if pd.notna(x) else 'NaT')

df

"""#Suggestion
#Method for Album Details and song details
"""

df.head(20)

def get_album_info(album_id):
    # Filter the DataFrame
    album_info = df[df['album_id'] == album_id]

    if not album_info.empty:
        album_name = album_info['album'].iloc[0]
        artists = album_info['artists'].iloc[0]
        print(f"Album Name: {album_name}")
        print(f"Artists: {artists}")

        # Get information about songs in the album
        songs_in_album = df[df['album_id'] == album_id][['id', 'name', 'duration_ms']]
        print("\nSongs in the Album:")
        print(songs_in_album)

        # Calculate and display the total duration of the album in minutes
        total_duration_ms = songs_in_album['duration_ms'].sum()
        #To convert total_duration_minutes from milisecond to minute divide by 6000
        total_duration_minutes = total_duration_ms / (1000 * 60)
        print(f"\nTotal Duration of the Album: {total_duration_minutes:.2f} minutes")
    else:
        print(f"No album found with ID {album_id}")

get_album_info('2eia0myWFgoHuttJytCxgX')

def get_album_info_by_name(album_name):
    # Filter the DataFrame
    album_info = df[df['album'] == album_name]

    if not album_info.empty:
        album_id = album_info['album_id'].iloc[0]
        artists = album_info['artists'].iloc[0]
        print(f"Album Name: {album_name}")
        print(f"Artists: {artists}")

        # Songs in the album
        songs_in_album = df[df['album_id'] == album_id][['id', 'name', 'duration_ms', 'release_date']]
        print("\nSongs in the Album:")
        print(songs_in_album)

        # Count the songs in the album
        num_songs = len(songs_in_album)
        print(f"\nNumber of Songs in the Album: {num_songs}")

        # Find and display the latest song release date
        #Latest relase dated song in the album will be the relase date of the album.
        latest_release_date = songs_in_album['release_date'].max()
        print(f"\nRelease Date Of The Album: {latest_release_date}")

        # Calculate and display the total duration of the album in minutes
        total_duration_ms = songs_in_album['duration_ms'].sum()
        total_duration_minutes = total_duration_ms / (1000 * 60)
        print(f"\nTotal Duration of the Album: {total_duration_minutes:.2f} minutes")
        #URL for Album
        AlbumUrl = album_info['AlbumSongsURL'].loc[0]
        print(f"Album URL: {AlbumUrl}")

    else:
        print(f"No album found with name {album_name}")

get_album_info_by_name('The Battle Of Los Angeles')

df.head(10)

def get_song_info_by_name(song_name):
    # Filter the DataFrame to a specified song
    song_info = df[df['name'] == song_name]

    if not song_info.empty:
        album_name = song_info['album'].iloc[0]
        artists = song_info['artists'].iloc[0]
        release_date = song_info['release_date'].iloc[0]
        track_number = song_info['track_number'].iloc[0]
        songId = song_info['id'].iloc[0]
        songUrl = song_info['TracksUrl'].iloc[0]

        print(f"Song Name: {song_name}")
        print(f"Song ID: {songId}")
        print(f"Album Name: {album_name}")
        print(f"Artists: {artists}")
        print(f"Release Date: {release_date}")
        print(f"Track Number: {track_number}")
        print(f"Track URL: {songUrl}")

    else:
        print(f"No song found with name {song_name}")

get_song_info_by_name('Testify')

def get_artist_info_by_name(artist_name):
   # Filter the DataFrame
    artist_info = df[df['artists'] == artist_name]

    if not artist_info.empty:
        artist_id = artist_info['artist_ids'].iloc[0]
        artist_name = artist_info['artists'].iloc[0]
        album_names = artist_info['album'].iloc[0]
        print(f"Artist Name: {artist_name}")
        print(f"Album Name: {album_names}")

        # Artist Songs
        artists_song = df[df['artist_ids'] == artist_id][['id', 'name', 'duration_ms', 'release_date']]
        print("\nArtist Songs:")
        print(artists_song)

        # Count the songs in the album
        num_songs = len(artists_song)
        print(f"\nNumber of Songs for Artist: {num_songs}")

        # Find and display the latest song release date
        #Latest relase dated song in the album will be the relase date of the album.
        latest_release_date = artists_song['release_date'].max()
        print(f"\nLatest Relased song for Artist: {latest_release_date}")

        # Calculate and display the total duration of the album in minutes
        total_duration_ms = artists_song['duration_ms'].sum()
        total_duration_minutes = total_duration_ms / (1000 * 60)
        print(f"\nTotal Duration for Artist: {total_duration_minutes:.2f} minutes")
        #URL for Album
        ArtistUrl = artist_info['ArtistSongsURL'].loc[0]
        print(f"Artist URL: {ArtistUrl}")

    else:
        print(f"No album found with name {album_name}")

get_artist_info_by_name("Rage Against The Machine")

"""Recommend a song with using NLP(Natural Language Processing)

By the help of the cosine_similarity function, which is typically part of the scikit-learn library in Python.
The system will suggest to the user the song that is closest to the song he/she is listening to and will present the features related to this song.
"""

# recommend_song function suggests the user the song that is closest to the song which he/she is listening to and will show the features related to this adviced song.
def recommend_song(song_name):
    # Filter the DataFrame to a specified song
    target_song_info = df[df['name'] == song_name]

    if not target_song_info.empty:
        # Extract audio features for the target song from target_song_info dataset.
        target_song_features = target_song_info[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]

        # Extract audio features for all other songs from the whole main dataset.
        other_song_features = df[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]

        # Calculate cosine similarity between the target song and all other songs
        similarities = cosine_similarity(target_song_features, other_song_features)[0]

        # Find the song with the highest similarity (most similar) but not the same song
        max_similarity = similarities.max()
        max_similarity_index = similarities.argmax()
        # Index corresponds to the position of the song in the dataset that has the highest cosine similarity to the target song.

        # Exclude the input song from the recommendations
        similarities[max_similarity_index] = -1  # Set similarity to a very low value to exclude it
        recommended_song_index = similarities.argmax()
        recommended_song_name = df.loc[recommended_song_index, 'name']
        recommended_song_album = df.loc[recommended_song_index, 'album']
        recommended_song_artists = df.loc[recommended_song_index, 'artists']

        print(f"Based on audio features, you might also like: {recommended_song_name} from the album '{recommended_song_album}' by {recommended_song_artists} (Similarity: {max_similarity:.2f})")
    else:
        print(f"Song not found in the dataset.")

recommend_song('Testify')

# recommend_album function suggests the user the album that is closest to the album which he/she is listening to and will show the features related to this adviced album.
# While operating, this function took advantage of the similarities in sound features in the dataset such as danceability, speechiness,acousticness.

def recommend_album(album_name):
    # Filter the DataFrame to a specified album
    target_album_info = df[df['album'] == album_name]

    if not target_album_info.empty:
        # Extract audio features for all songs in the target album
        target_album_features = target_album_info[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]

        # Extract audio features for all other songs
        other_song_features = df[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]

        # Calculate cosine similarity between the target album and all other songs
        similarities = cosine_similarity(target_album_features, other_song_features)

        # Sum the similarities for each song to represent the similarity of the entire album
        album_similarity = similarities.sum(axis=0)

        # Find the album with the highest similarity (most similar) but not the same album
        max_similarity = album_similarity.max()
        max_similarity_index = album_similarity.argmax()

        # Exclude the input album from the recommendations
        album_similarity[max_similarity_index] = -1  # Set similarity to a very low value to exclude it
        recommended_album_name = df.loc[max_similarity_index, 'album']
        recommended_album_artists = df.loc[max_similarity_index, 'artists']

        # Get information about the recommended album (names of songs and count of songs)
        recommended_album_info = df[df['album'] == recommended_album_name]
        recommended_album_song_names = recommended_album_info['name'].tolist()
        recommended_album_song_count = len(recommended_album_info)

        print(f"Based on audio features, you might also like the album: {recommended_album_name} by {recommended_album_artists} (Similarity: {max_similarity:.2f})")
        print(f"Recommended Album Song Count: {recommended_album_song_count}")
        print(f"Recommended Album Songs:")
        for song_name in recommended_album_song_names:
            print(f"- {song_name}")
    else:
        print(f"Album not found in the dataset.")

recommend_album('The Battle Of Los Angeles')

"""Modifications(28.12.23)

Hedefler:

1)Ünlü türk gruplarından album album türkçe şarkı çek spotify API csv formatında

2) Mood analysis -> muzik değerleri liveness tempo vs mood belirleme. --OK

3) Kullanıcının dinlediği şarkıların moodunun algılanması ve onların mooduna yakın şarkı önerme. -- OK

4) Favori dinlediği sanatçısı ve şarkısı dinlenme sayısı.

estimate_mood -> estimates the songs mood

suggest_songs -> takes the user listened song list and with it analyzes the past songs mood and suggests similiar mood songs.

predict_song_mood function

The mood values ​​in the dataset are adapted according to the following rules.
And mood column created in our dataset.

Danceability:

High danceability often suggests an energetic and lively mood. Songs with a strong beat and rhythm are likely to be more danceable.

Speechiness:

Higher speechiness might indicate a more narrative or lyrical focus, which could contribute to the mood. Songs with more lyrics might convey specific emotions or stories.

Acousticness:

Higher acousticness may suggest a more organic or intimate feel, which is often associated with a calm or relaxed mood.

Instrumentalness:

A high instrumentalness value suggests a lack of vocals. Instrumental tracks can evoke various moods depending on factors like tempo, key, and instrumentation.

Liveness:

High liveness may suggest a live recording, which can add energy and excitement to a song. Live recordings might evoke a sense of immediacy and connection with the audience.

Valence:

Valence represents the musical positiveness conveyed by a track. Higher valence values typically indicate a happier or more positive mood, while lower values suggest a sadder or more negative mood.

Tempo:

Tempo influences the perceived energy of a song. Faster tempos are often associated with energetic or intense moods, while slower tempos can evoke a more relaxed or melancholic atmosphere.

Loudness:

Higher loudness can contribute to a more energetic or powerful mood, while lower loudness might suggest a softer or more subdued atmosphere.

Mode:

The mode (major or minor) can influence the emotional character of a song. Major keys are generally associated with positive and uplifting moods, while minor keys often convey a sadder or more melancholic tone.

Key:

The key of a song can also influence its emotional impact. Different keys are often associated with different moods, although individual preferences and cultural influences play a significant role.
"""

#This function used for creating a mood column in our database.
df.columns = df.columns.str.strip()
def estimate_mood(row):
    if row['danceability'] > 0.7:
        return 'energetic'
    elif row['speechiness'] > 0.5:
        return 'narrative'
    elif row['acousticness'] > 0.6:
        return 'calm'
    elif row['instrumentalness'] > 0.7:
        return 'instrumental'
    elif row['liveness'] > 0.6:
        return 'live'
    elif row['valence'] > 0.5:
        return 'positive'
    elif row['tempo'] > 120:
        return 'fast tempo'
    elif row['loudness'] > -5:
        return 'loud'
    elif row['mode'] == 1:
        return 'major'
    else:
        return 'neutral'

df['mood'] = df.apply(estimate_mood, axis=1)

print(df[['name', 'mood']])

df

"""With this code, We created a mood column in the dataset by using features of the songs such as 'danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key'. created."""

label_encoder = LabelEncoder()
df['mood_encoded'] = label_encoder.fit_transform(df['mood'])

# Train-test
features = df[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]
X_train, X_test, y_train, y_test = train_test_split(features, df['mood_encoded'], test_size=0.2, random_state=42)

# Train a RandomForestClassifier without parallelization
model = RandomForestClassifier(n_estimators=100, random_state=42, max_depth=10)
model.fit(X_train, y_train)

"""This function is used to predict the mood for whole dataframe by using machine learning RandomForestClassifer and label encoder.
By this function when new songs are added the mood of the new songs will be predicted authomaticaly.
"""

def train_mood_prediction_model(df):
    df.columns = df.columns.str.strip()

    features = df[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]
    label_encoder = LabelEncoder()
    df['mood_encoded'] = label_encoder.fit_transform(df['mood'])
    model = RandomForestClassifier(n_estimators=100, random_state=42, n_jobs=-1, max_depth=10)
    model.fit(features, df['mood_encoded'])

    return model, label_encoder

"""This fucntion is used to predict the song's mood"""

def predict_song_mood(song_name, model, label_encoder, df):
    song_features = df[df['name'] == song_name][['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']].values

    if len(song_features) == 0:
        return "Song not found in the dataset"
    predicted_mood_encoded = model.predict(song_features)[0]
    predicted_mood = label_encoder.inverse_transform([predicted_mood_encoded])[0]
    return predicted_mood

#Predict_song_mood function example
trained_model, label_encoder = train_mood_prediction_model(df)
song_name_to_predict = "Testify"
predicted_mood = predict_song_mood(song_name_to_predict, trained_model, label_encoder, df)
print(f"The predicted mood for '{song_name_to_predict}' is: {predicted_mood}")

"""Prediction of the songs mood for the whole dataframe and prediction time."""

df.columns = df.columns.str.strip()
features = df[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]
df['mood'] = df['mood']
label_encoder = LabelEncoder()
df['mood_encoded'] = label_encoder.fit_transform(df['mood'])
X_train, X_test, y_train, y_test = train_test_split(features, df['mood_encoded'], test_size=0.2, random_state=42)

start_time = time.time()

model = RandomForestClassifier(n_estimators=100, random_state=42, n_jobs=-1, max_depth=10)
model.fit(X_train, y_train)

end_time = time.time()
training_time = end_time - start_time
print(f"Training Time: {training_time} seconds")

start_time = time.time()
df['predicted_mood_encoded'] = model.predict(features)

df['predicted_mood'] = label_encoder.inverse_transform(df['predicted_mood_encoded'])

end_time = time.time()
prediction_time = end_time - start_time
print(f"Prediction Time: {prediction_time} seconds")

print(df[['name', 'mood', 'predicted_mood']])

"""Using this mood column and machine learning, the suggest_songs function was prepared to suggest a suitable song to the user based on the music the user has listened to before."""

df.head(5)

df["mood"].value_counts()

calm = df[df["mood"]=="calm"].sample(n=1000)
positive = df[df["mood"]=="positive"].sample(n=1000)
energetic = df[df["mood"]=="energetic"].sample(n=1000)
fast_tempo = df[df["mood"]=="fast tempo"].sample(n=1000)
instrumental = df[df["mood"]=="instrumental"].sample(n=1000)
major = df[df["mood"]=="major"].sample(n=1000)
live = df[df["mood"]=="live"].sample(n=1000)
neutral = df[df["mood"]=="neutral"].sample(n=1000)
loud = df[df["mood"]=="loud"].sample(n=1000)
narrative = df[df["mood"]=="narrative"].sample(n=1000)
sample_df = pd.concat([calm,positive,energetic,fast_tempo,instrumental,major,live,neutral,loud,narrative],ignore_index=True)
sample_df["mood"].value_counts()

# Copy the DataFrame
df_copy = sample_df.copy()

        # Label Encoding
label_encoder = LabelEncoder()
df_copy['mood_encoded'] = label_encoder.fit_transform(df_copy['mood'])

        # Train the model using the entire DataFrame
features = df_copy[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]
X_train, y_train = features, df_copy['mood_encoded']

        # Train the model
model = RandomForestClassifier(n_estimators=100, random_state=42, max_depth=10)
model.fit(X_train, y_train)

model.predict(df[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']][1:2])

test_df = df[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']][15000:15005]
model.predict_proba(test_df)

df[["mood"]][15000:15005]

# Take the user listened songs as a parameter and by looking at the mood of the songs recommend other songs.
def suggest_songs(user_listened_songs, df, sample_df):
    try:
        # Copy the DataFrame
        df_copy = sample_df.copy()

        # Label Encoding
        label_encoder = LabelEncoder()
        df_copy['mood_encoded'] = label_encoder.fit_transform(df_copy['mood'])

        # Train the model using the entire DataFrame
        features = df_copy[['danceability', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key']]
        X_train, y_train = features, df_copy['mood_encoded']

        # Train the model
        model = RandomForestClassifier(n_estimators=100, random_state=42, max_depth=10)
        model.fit(X_train, y_train)

        # Get the average features of the user's listened songs
        user_avg_features = df[df['name'].isin(user_listened_songs)][['danceability', 'speechiness', 'acousticness', 'instrumentalness',
                                                                         'liveness', 'valence', 'tempo', 'loudness', 'mode', 'key', 'mood']].mean()

        # Reshape the features for prediction
        user_avg_features = user_avg_features.values.reshape(1, -1)
        predicted_mood_encoded = model.predict(user_avg_features)[0]
        print(predicted_mood_encoded)

        label_dict = {0: "calm", 1: "positive", 2: "energetic", 3: "fast tempo", 4: "instrumental", 5: "major", 6: "live", 7: "neutral", 8: "loud", 9: "narrative"}
        predicted_label = label_dict[predicted_mood_encoded]

        # predicted songs with the same mood
        all_predicted_songs = df[df["mood"] == predicted_label]

        # Recommend 10 song
        recommended_songs = all_predicted_songs.sample(n=10)['name'].tolist()

        return recommended_songs

    except ValueError as e:
        print(f"Error: {e}")
        return []

# Example usage
user_listened_songs = ["Testify", "Guerilla Radio", "Calm Like a Bomb"]
suggested_songs = suggest_songs(user_listened_songs, df, sample_df)
print("Suggested Songs: " + ", ".join(suggested_songs))